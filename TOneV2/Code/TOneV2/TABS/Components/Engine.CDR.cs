using System;
using System.Collections.Generic;
using System.Linq;

namespace TABS.Components
{

    public partial class Engine
    {
        /// <summary>
        /// An event triggered when CDRs are imported from switches, but before being saved to CDR Stores
        /// </summary>
        public static event Action<IList<CDR>> CDRsImportedNotSaved;

        /// <summary>
        /// An event triggered when CDRs are imported from switches, after being saved to CDR Stores
        /// </summary>
        public static event Action<IList<CDR>> CDRsImportedAndStored;

        /// <summary>
        /// An event triggered when billing 
        /// </summary>
        public static event Action<IEnumerable<Billing_CDR_Base>> BillingCDRsGenerated;

        /// <summary>
        /// An event triggered when repricing 
        /// </summary>
        public static event Action<CdrRepricingParameters> PricingComplete;

        internal static void PricingCompleteNotify(log4net.ILog log, CdrRepricingParameters parameters)
        {
            if (PricingComplete != null)
            {
                foreach (var subsriber in PricingComplete.GetInvocationList())
                {
                    try
                    {
                        subsriber.DynamicInvoke(parameters);
                    }
                    catch (Exception invokeEx)
                    {
                        log.Error(string.Format("Error Invoking PricingComplete on {0}", subsriber.GetType()), invokeEx);
                        logMail.Error(string.Format("Error Invoking PricingComplete on {0}", subsriber.GetType()), invokeEx);
                    }
                }
            }
        }

        static object AlertSync = new object();

        public static CodeMap CdrImportCodeMap = null;
        public static CodeMap PricingCodeMap = null;

        /// <summary>
        /// Generate alerts (if necessary) from the given traffic stats. 
        /// The system will check for all (enabled) Criteria and generate Alerts accordingly.
        /// </summary>
        /// <param name="trafficStats">The Traffic stats from which to get any possible alerts</param>
        /// <returns>An enumerable collection of alerts generated by the alerts</returns>
        public static IEnumerable<Extensibility.IAlert> GetAlerts(IEnumerable<Billing_CDR_Base> cdrs)
        {
            log4net.ILog log = log4net.LogManager.GetLogger("Check for Alerts");
            lock (Engine.AlertSync)
            {
                List<Extensibility.IAlert> alerts = new List<TABS.Extensibility.IAlert>();
                foreach (PersistedAlertCriteria persistedCriteria in PersistedAlertCriteria.All.Values)
                {
                    if (persistedCriteria.IsEnabled.HasValue && persistedCriteria.IsEnabled.Value)
                        alerts.AddRange(persistedCriteria.AlertCriteria.ProcessTraffic(cdrs));
                }
                return alerts;
            }
        }

        /// <summary>
        /// Check for alerts that should be generated by the Alert Criterias.
        /// This should be called on periodic basis so that Alert Criterias depending on time would 
        /// Function properly
        /// </summary>
        //protected static void PeriodicAlertsCheck()
        //{
        //    lock (Engine.AlertSync)
        //    {
        //        List<Extensibility.IAlert> alerts = new List<TABS.Extensibility.IAlert>();
        //        foreach (PersistedAlertCriteria persistedCriteria in PersistedAlertCriteria.All.Values)
        //            if (persistedCriteria.IsEnabled.HasValue && persistedCriteria.IsEnabled.Value)
        //                alerts.AddRange(persistedCriteria.AlertCriteria.GetTimeAlerts());
        //    }
        //}

        /// <summary>
        /// The periodic alerts checker worker thread function
        /// </summary>
        //internal static void PeriodicAlertsChecker()
        //{
        //    // Sleep a minute
        //    System.Threading.Thread.Sleep(60 * 1000);

        //    // While the task manager is not requested to shutdown (global shutdown)
        //    while (!TaskManager.Instance.ShutDownRequested)
        //    {
        //        // Sleep a minute
        //        System.Threading.Thread.Sleep(60 * 1000);

        //        PeriodicAlertsCheck();
        //    }
        //}

        /// <summary>
        /// Regenerate Billing CDRs and Traffic Stats from previously imported CDRs for a selected switch.
        /// </summary>
        public static void RegenerateFromCDRs(CdrRepricingParameters parameters)
        {
            if (IsRepricingRunning)
                CdrRepricingParameters.Add(parameters);
            else
                CdrProcessor.Process(parameters);
        }

        /// <summary>
        /// Fill CDR Info (Main / Invalid) from the standard CDR (imported from the switch)
        /// </summary>
        /// <param name="sourceSwitch">The Switch from which the standard CDR is imported</param>
        /// <param name="standardCDR">imported standard CDR</param>
        /// <param name="baseCDR">The Base (Main / Invalid) CDR</param>
        protected static bool FillCDRInfo(Switch sourceSwitch, TABS.Addons.Utilities.Extensibility.CDR standardCDR, Billing_CDR_Base baseCDR)
        {
            return sourceSwitch.SwitchManager.FillCDRInfo(sourceSwitch, standardCDR, baseCDR);
        }

        internal static List<CdrImportHandler> CdrImportHandlers = new List<CdrImportHandler>();

        public static Billing_CDR_Base GenerateBillingCdr(CodeMap codeMap, ref int validCount, CDR cdr)
        {
            return CdrProcessor.GenerateBillingCdr(codeMap, ref validCount, cdr);
        }

        /// <summary>
        /// Get the CDRs from all switches defined in the System
        /// </summary>
        /// <returns></returns>
        public static bool GetCDRsFromSwitches()
        {
            if (IsCDRImportRunning) return false;
            else _IsCDRImportRunning = true;

            bool success = false;

            _IsCDRStopRequested = false;

            log4net.ILog log = log4net.LogManager.GetLogger("TABS.CDR.Import");
            log.Info("Starting CDR Import from all switches");

            List<CDR> allCDRs = new List<CDR>();

            Dictionary<Switch, string> importTags = new Dictionary<Switch, string>();
            CdrImportHandlers.Clear();

            // create an import handler for each switch
            foreach (Switch definedSwitch in Switch.All.Values)
            {
                // If Switch is not included in CDR Import, skip it
                if (!definedSwitch.Enable_CDR_Import || definedSwitch.SwitchManager == null) continue;
                // Create a handler for the switch
                CdrImportHandler switchHandler = new CdrImportHandler(definedSwitch);
                CdrImportHandlers.Add(switchHandler);
                // Backup the import Tag to restore it in case of error
                importTags[definedSwitch] = definedSwitch.LastCDRImportTag;
            }

            // Keep running Until all handlers finish
            bool keepWaiting = true;
            DateTime start = DateTime.Now;
            TimeSpan timeOut = SystemParameter.CDR_Import_TimeOut.TimeSpanValue.Value;

            do
            {
                keepWaiting = true;
                TimeSpan waiting = DateTime.Now.Subtract(start);

                if (waiting > timeOut)
                {
                    keepWaiting = false;

                    // Finished if all finished
                    foreach (CdrImportHandler handler in CdrImportHandlers)
                        if (!handler.Finished)
                        {
                            log.ErrorFormat("CDR Import Handler for Switch: {0} has Timed Out ({1})", handler.Switch, timeOut);
                            logMail.ErrorFormat("CDR Import Handler for Switch: {0} has Timed Out ({1})", handler.Switch, timeOut);
                            handler.Abort();
                        }

                    break;
                }
                else
                {
                    bool allFinished = true;

                    // Finished if all finished
                    foreach (CdrImportHandler handler in CdrImportHandlers)
                    {
                        keepWaiting = handler.IsRunning ? true : keepWaiting;
                        allFinished = allFinished && handler.Finished;
                    }

                    if (allFinished) break;

                    // Wait 1 second
                    System.Threading.Thread.Sleep(1000);
                }
            }
            while (keepWaiting);

            // Add all cdrs
            foreach (var handler in CdrImportHandlers)
                if (handler.CDR != null && handler.CDR.Count > 0)
                    allCDRs.AddRange(handler.CDR);

            try
            {
                log.InfoFormat("Imported {0} total CDR Records", allCDRs.Count);

                // If anything was imported
                if (allCDRs.Count > 0)
                {
                    #region CDRs Imported Not Saved Event
                    if (CDRsImportedNotSaved != null)
                    {
                        foreach (var subsriber in CDRsImportedNotSaved.GetInvocationList())
                        {
                            try
                            {
                                CDRsImportedNotSaved(allCDRs);
                            }
                            catch (Exception invokeEx)
                            {
                                log.Error(string.Format("Error Invoking CDRs Imported on {0}", subsriber.GetType()), invokeEx);
                                logMail.Error(string.Format("Error Invoking CDRs Imported on {0}", subsriber.GetType()), invokeEx);
                            }
                        }

                    }
                    #endregion

                    List<Billing_CDR_Base> billingCDRs = new List<Billing_CDR_Base>(allCDRs.Count);

                    // Save imported CDR records
                    using (NHibernate.ISession session = DataConfiguration.OpenSession())
                    {
                        try
                        {
                            // Save CDRs
                            bool seriousError = false;
                            Addons.Runnables.CDRImportRunner.status = "Saving CDRs to Stores";

                            bool saveSuccess = CDRStoreManager.Save(session, allCDRs, out seriousError);
                            if (saveSuccess)
                                log.InfoFormat("Successfully Saved {0} Imported CDR records to all configured Stores", allCDRs.Count);

                            // If some Stores got the cdrs, others not...
                            if (!seriousError)
                            {
                                if (!saveSuccess)
                                    log.InfoFormat("Saved {0} Imported CDR records to a number (not all) of configured Stores. View Details in log for failures.", allCDRs.Count);

                                // Update Switches
                                foreach (CdrImportHandler handler in CdrImportHandlers)
                                {
                                    if (handler.CDR.Count > 0)
                                    {
                                        handler.Switch.SwitchManager.UpdateLastCDRTag(handler.Switch, handler.CDR[handler.CDR.Count - 1]);
                                        var lastAttempt = handler.CDR.Max(c => c.AttemptDateTime);
                                        if (!handler.Switch.LastAttempt.HasValue || lastAttempt > handler.Switch.LastAttempt.Value)
                                            handler.Switch.LastAttempt = lastAttempt;
                                        handler.Switch.LastImport = handler.LastImport;
                                        DataHelper.ExecuteNonQuery("UPDATE [Switch] SET LastImport = @P1, LastCDRImportTag = @P2, LastAttempt = @P3 WHERE SwitchID = @P4", handler.Switch.LastImport.Value, handler.Switch.LastCDRImportTag, handler.Switch.LastAttempt, handler.Switch.SwitchID);
                                        log.InfoFormat("Updated Switch {0} after CDR Import, Last Tag: {1}, Last Import: {2}, Batch Last Attempt: {3}", handler.Switch, handler.Switch.LastCDRImportTag, handler.Switch.LastImport, lastAttempt);
                                    }
                                    else
                                    {
                                        log.InfoFormat("Handler for {0} returns 0 CDRs", handler.Switch);
                                        try
                                        {
                                            DataHelper.ExecuteNonQuery(
                                                @"UPDATE [Switch] SET LastCDRImportTag = @P1 WHERE SwitchID = @P2"
                                                , handler.Switch.LastCDRImportTag
                                                , handler.Switch.SwitchID);
                                            log.InfoFormat("Updating virtually the last cdr tag for {0}", handler.Switch);
                                        }
                                        catch (Exception ex)
                                        {
                                            log.Error(string.Format("could not update swith {0}", handler.Switch), ex);
                                        }
                                    }
                                    handler.Dispose();
                                }

                                //TABS.Switch.ClearCachedCollections();

                                // Build the Code Map for the first Attempt
                                DateTime firstAttemptDate = allCDRs.Min(c => c.AttemptDateTime).Date;
                                DateTime codeMapStart = DateTime.Now;
                                if (CdrImportCodeMap == null || !CdrImportCodeMap.StartDate.Equals(firstAttemptDate))
                                {
                                    string msg = string.Format("Building Codemap for date {0:yyyy-MM-dd}", firstAttemptDate);
                                    log.Info(msg);
                                    Addons.Runnables.CDRImportRunner.status = msg;
                                    CdrImportCodeMap = null;
                                    //TABS.CodeMap.ClearCachedCollections();
                                    GC.Collect();
                                    CdrImportCodeMap = new CodeMap(firstAttemptDate);
                                    log.InfoFormat("Built Codemap for date {0:yyyy-MM-dd} in {1}", firstAttemptDate, DateTime.Now.Subtract(codeMapStart));
                                }
                                else
                                {
                                    log.InfoFormat("Using Codemap for date {0:yyyy-MM-dd}", CdrImportCodeMap.StartDate);
                                }

                                #region CDRs Imported And Stored Event
                                if (CDRsImportedAndStored != null)
                                {
                                    foreach (var subsriber in CDRsImportedAndStored.GetInvocationList())
                                    {
                                        try
                                        {
                                            CDRsImportedAndStored(allCDRs);
                                        }
                                        catch (Exception invokeEx)
                                        {
                                            log.Error(string.Format("Error Invoking CDRs Imported And Stored on {0}", subsriber.GetType()), invokeEx);
                                            logMail.Error(string.Format("Error Invoking CDRs Imported And Stored on {0}", subsriber.GetType()), invokeEx);
                                        }
                                    }
                                }
                                #endregion

                                // Create Billing CDRs
                                log.Info("Creating Billing Records from Imported CDRs");
                                int validCount = 0;
                                foreach (CDR cdr in allCDRs)
                                    billingCDRs.Add(GenerateBillingCdr(CdrImportCodeMap, ref validCount, cdr));
                                log.InfoFormat("Created Billing Records ({0:#,###} valid, {1:#,###} invalid) from {2:#,###} CDRs", validCount, allCDRs.Count - validCount, allCDRs.Count);

                                #region Billing CDRs Generated Event
                                // Trigger events for Billing CDR generation subscribers 
                                if (BillingCDRsGenerated != null)
                                {
                                    foreach (var subsriber in BillingCDRsGenerated.GetInvocationList())
                                    {
                                        try
                                        {
                                            subsriber.DynamicInvoke(billingCDRs);
                                        }
                                        catch (Exception invokeEx)
                                        {
                                            log.Error(string.Format("Error Invoking BillingCDRsGenerated on {0}", subsriber.GetType()), invokeEx);
                                            logMail.Error(string.Format("Error Invoking BillingCDRsGenerated on {0}", subsriber.GetType()), invokeEx);
                                        }
                                    }
                                }
                                #endregion

                                // Write Billing CDRs
                                Addons.Runnables.CDRImportRunner.status = "Writing billing CDRs";
                                CdrProcessor.WriteBillingCDRs(log, billingCDRs);
                                success = true;
                            }
                            else // Serious Error: No CDRs were stored
                            {
                                throw new Exception("Serious Error while Saving CDRs. View Details in Log to Check for problems in CDR Stores.");
                            }
                        }
                        catch (Exception ex)
                        {
                            log.Error(string.Format("Error After CDR Import"), ex);
                            logMail.Error(string.Format("Error After CDR Import"), ex);
                            session.Flush();
                            success = false;
                        }
                    }
                    // Traffic Monitor Update?
                    if (success && billingCDRs != null)
                    {
                        log.Info("Updating Traffic Stats");
                        Addons.Runnables.CDRImportRunner.status = "Updating Traffic Stats";
                        // Traffic Stats
                        int SampleMinutes = (int)(60 / SystemParameter.TrafficStatsSamplesPerHour.NumericValue.Value);
                        UpdateTrafficStats(SampleMinutes, _TrafficStatsCache, billingCDRs, true);

                        lock (typeof(TrafficStats))
                        {
                            FlushInvalidEntries();
                            Exception exc;
                            using (TABS.Components.BulkManager BM = new TABS.Components.BulkManager(log))
                            {
                                BM.WriteAndUpdateTrafficStats(_TrafficStatsCache.Values.Where(ts => ts.Saveable), out exc);
                            }

                            if (exc != null)
                            {
                                _TrafficStatsCache.Clear();
                            }
                        }
                        _DailyTrafficStats = new Dictionary<string, TrafficStats>();
                        UpdateDailyTrafficStats(_DailyTrafficStats, billingCDRs, true);
                        // //Update old Traffic Stats
                        //lock (typeof(TrafficStats))
                        //{
                        //    using (NHibernate.ISession session = DataConfiguration.OpenSession())
                        //    {
                        //        var transaction = session.BeginTransaction();
                        //        try
                        //        {
                        //            lock (typeof(TrafficStats))
                        //            {
                        //                FlushInvalidEntries();
                        //                foreach (var trafficStat in _TrafficStatsCache.Values.Where(ts => ts.Saveable))
                        //                    session.SaveOrUpdate(trafficStat);
                        //                transaction.Commit();
                        //                session.Flush();
                        //                session.Close();
                        //            }
                        //        }
                        //        catch (Exception tsEx)
                        //        {
                        //            transaction.Rollback();
                        //            TABS.Components.Engine._TrafficStatsCache.Clear();
                        //            log.Error(string.Format("Error Saving Traffic Stats"), tsEx);
                        //            logMail.Error(string.Format("Error Saving Traffic Stats"), tsEx);
                        //        }
                        //        //session.Flush();
                        //       // session.Close();
                        //    }
                        //}

                        //if (!TABS.Components.Engine.IsCheckForAlertsRunning)
                        //    TABS.Addons.Runnables.AlertCheckRunner.billingCDRs = billingCDRs;

                        ////
                        //bool isalertTaskEnabled = false;
                        //var alertTask = TABS.Components.TaskManager.TaskList.Where(t => ((TABS.PersistedRunnableTask)t).KnownIRunnableClass != null && ((TABS.PersistedRunnableTask)t).KnownIRunnableClass.Trim() == "T.One - Alerts Runnable"); ;
                        //if (alertTask != null)
                        //    isalertTaskEnabled = alertTask.Single().IsEnabled;

                        //if (!isalertTaskEnabled)
                        //{
                        //Exception ex;

                        // Alerts
                        //Addons.Runnables.CDRImportRunner.status = "Checking for Alerts";
                        //log.Info("Checking for Alerts");
                        //IEnumerable<Extensibility.IAlert> alerts = GetAlerts(billingCDRs);
                        //log.Info("Saving Alerts");
                        //using (NHibernate.ISession session = DataConfiguration.OpenSession())
                        //{
                        //    if (!ObjectAssembler.SaveXorUpdate(session, alerts, out ex, true) && ex != null)
                        //    {
                        //        log.Error("Error Saving Alerts", ex);
                        //        logMail.Error("Error Saving Alerts", ex);
                        //    }
                        //    session.Flush();
                        //    session.Close();
                        //}

                    }
                }
            }
            catch (Exception ex)
            {
                log.Error("Error in Importing CDR from all switches", ex);
                logMail.Error("Error in Importing CDR from all switches", ex);
            }

            log.Info("Finished Importing CDR from all switches");

            // Mark operation as ready for next run
            _IsCDRStopRequested = false;
            _IsCDRImportRunning = false;

            Addons.Runnables.CDRImportRunner.status = string.Empty;
            foreach (CdrImportHandler handler in CdrImportHandlers)
                handler.Dispose();

            CdrImportHandlers = null;
            GC.Collect();
            CdrImportHandlers = new List<CdrImportHandler>();
            return true;
        }


        /// <summary>
        /// Generate the Pricing information for the CDR records
        /// </summary>
        /// <returns>False if operation is already running, true if it started and ended (or stopped)</returns>
        public static bool GenerateCDRPricing()
        {
            if (IsCDRPricingRunning) return false;
            else _IsCDRPricingRunning = true;

            GC.Collect();

            _IsCDRStopRequested = false;

            bool success = false;

            SystemParameter batchSizeParam = SystemConfiguration.KnownParameters[KnownSystemParameter.sys_CDR_Pricing_Batch_Size];
            SystemParameter lastPricedCdrIDParam = SystemConfiguration.KnownParameters[KnownSystemParameter.sys_CDR_Pricing_CDRID];
            long lastPricedCdrID = (long)lastPricedCdrIDParam.NumericValue;
            long lastPricedCdrIDBackup = lastPricedCdrID;
            int batchSize = (int)batchSizeParam.NumericValue;

            log4net.ILog log = log4net.LogManager.GetLogger("TABS.CDR.Pricing");

            try
            {
                IList<TABS.Billing_CDR_Main> billingCDRs = new List<Billing_CDR_Main>();

                using (NHibernate.ISession session = DataConfiguration.OpenSession())
                {
                    string hql = string.Format("FROM Billing_CDR_Main BM WHERE BM.ID > {0} ORDER BY BM.ID", lastPricedCdrID);

                    NHibernate.IQuery query = session.CreateQuery(hql)
                        .SetMaxResults(batchSize)
                        .SetCacheable(false);
                    query.SetLockMode("BM", NHibernate.LockMode.None);
                    // query.SetLockMode("TABS.Billing_CDR_Main", NHibernate.LockMode.None);
                    DateTime start = DateTime.Now;
                    billingCDRs = query.List<TABS.Billing_CDR_Main>();
                    TimeSpan spent = DateTime.Now.Subtract(start);
                    if (billingCDRs.Count > 0)
                        log.InfoFormat("Loaded {0} Billing Main CDRs from ({1} to {2}) in {3}", billingCDRs.Count, billingCDRs[0].ID, billingCDRs[billingCDRs.Count - 1].ID, spent);
                    session.Clear();
                    session.Flush();
                    session.Close();
                }

                if (billingCDRs.Count > 0)
                {
                    List<Billing_CDR_Base> cdrs = new List<Billing_CDR_Base>();

                    DateTime pricingStart = DateTime.MaxValue;

                    // Get the minimum attempt date/time from the billed CDRs
                    foreach (Billing_CDR_Main main in billingCDRs) if (pricingStart > main.Attempt) pricingStart = main.Attempt;

                    using (NHibernate.ISession session = DataConfiguration.OpenSession())
                    {
                        PricingGenerator generator = null;
                        using (generator = new PricingGenerator(session, pricingStart))
                        {
                            log.InfoFormat("Generating Pricing Information for {0} CDRs Starting from ID: {1}", billingCDRs.Count, lastPricedCdrID);

                            // Generate pricing Information for each main CDR
                            foreach (Billing_CDR_Main main in billingCDRs)
                            {
                                if (IsCDRStopRequested) break;
                                main.Billing_CDR_Cost = generator.Get<Billing_CDR_Cost>(main);
                                main.Billing_CDR_Sale = generator.Get<Billing_CDR_Sale>(main);
                                if (main.Billing_CDR_Sale == null)
                                {
                                    // There is a need to a code map....
                                    if (Engine.PricingCodeMap == null || !Engine.PricingCodeMap.StartDate.Equals(pricingStart.Date))
                                    {
                                        Engine.PricingCodeMap = null;
                                        //TABS.CodeMap.ClearCachedCollections();
                                        Engine.PricingCodeMap = new CodeMap(pricingStart.Date);
                                    }
                                    generator.FixParentCodeSale(main, null, null, Engine.PricingCodeMap);
                                }

                                TABS.Code SaleCode = null;
                                TABS.Code CostCode = null;

                                //if (main != null)
                                //{
                                //    if (!string.IsNullOrEmpty(main.CDPN))
                                //    {
                                //        SaleCode = Engine.PricingCodeMap.Find(main.CDPN, TABS.CarrierAccount.SYSTEM, pricingStart.Date);
                                //        main.OurCode = SaleCode;
                                //        if (main.Supplier != null)
                                //        {
                                //            CostCode = Engine.PricingCodeMap.Find(main.CDPN, main.Supplier, pricingStart.Date);
                                //            main.SupplierCode = CostCode;
                                //        }
                                //    }
                                //}

                                //if (main != null && main.Billing_CDR_Cost != null && CostCode != null)
                                //    main.Billing_CDR_Cost.Code = CostCode;

                                //if (main != null && main.Billing_CDR_Sale != null && SaleCode != null)
                                //    main.Billing_CDR_Sale.Code = SaleCode;


                                CdrProcessor.HandlePassThrough(main);
                                lastPricedCdrID = main.ID;
                                cdrs.Add(main);
                            }
                        }
                        generator.Dispose();
                        generator = null;
                        session.Clear();
                        session.Flush();
                        session.Close();
                    }
                    GC.Collect(); GC.Collect();

                    // Write the Sale and Cost
                    if (cdrs.Count > 0)
                    {
                        // Delete overlapping Pricing Info (Fix to cost primary key violation when pricing stops)
                        int costsDeleted = DataHelper.ExecuteNonQuery("DELETE FROM Billing_CDR_Cost WHERE ID > @P1", lastPricedCdrIDBackup);
                        int salesDeleted = DataHelper.ExecuteNonQuery("DELETE FROM Billing_CDR_Sale WHERE ID > @P1", lastPricedCdrIDBackup);
                        if (costsDeleted > 0 || salesDeleted > 0)
                            log.WarnFormat("Deleted overlapping records: {0} Cost and {1} Sale", costsDeleted, salesDeleted);

                        // Write fresh pricing information
                        Components.BulkManager BulkManager = null;
                        using (BulkManager = new BulkManager(log))
                            BulkManager.WriteBillingSaleAndCost(cdrs);
                        BulkManager.Dispose();
                        Components.BulkManager.Clear();
                        BulkManager = null;

                        // Update last Priced CDR ID
                        try
                        {
                            using (NHibernate.ISession session = DataConfiguration.OpenSession())
                            {
                                NHibernate.ITransaction transaction = session.BeginTransaction();
                                lastPricedCdrIDParam.NumericValue = lastPricedCdrID;
                                session.Update(lastPricedCdrIDParam);
                                transaction.Commit();
                                transaction.Dispose();
                                session.Flush();
                                session.Close();
                                log.InfoFormat("Updated Last Priced CDR ID TO {0}", lastPricedCdrID);
                            }
                        }
                        catch (Exception ex)
                        {
                            log.Error(string.Format("Updating Last Pricing Tag to {0}", lastPricedCdrID), ex);
                            logMail.Error(string.Format("Updating Last Pricing Tag to {0}", lastPricedCdrID), ex);
                        }
                    }
                    cdrs = null;
                }
                billingCDRs = null;
                success = true;
            }
            catch (Exception ex)
            {
                log.Error(string.Format("Generating Pricing Information for {0} CDRs Starting from ID: {1}", batchSize, lastPricedCdrID), ex);
                logMail.Error(string.Format("Generating Pricing Information for {0} CDRs Starting from ID: {1}", batchSize, lastPricedCdrID), ex);
                success = false;
                GC.Collect(); GC.Collect();
            }

            _IsCDRPricingRunning = false;
            _IsCDRStopRequested = false;
            GC.Collect(); GC.Collect();
            GC.Collect(); GC.Collect();
            return success;
        }
    }
}