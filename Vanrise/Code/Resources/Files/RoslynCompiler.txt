using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace CompilerStandard
{
    public class Compiler
    {
        static Dictionary<string, Assembly> s_dynamicAssembliesByName = new Dictionary<string, Assembly>();

        static Compiler()
        {
            AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;
        }

        static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)
        {
            return s_dynamicAssembliesByName[args.Name.Substring(0, args.Name.IndexOf(','))];
        }

        public void Compile(string codeToCompile, string fullNameSpace)
        {
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(codeToCompile);

            string assemblyName = String.Format("RuntimeAssembly_{0}", Guid.NewGuid().ToString("N"));

            List<MetadataReference> references = new List<MetadataReference>();

            string path = Path.GetDirectoryName(AppDomain.CurrentDomain.BaseDirectory);
            foreach (string fileName in Directory.GetFiles(path, "*.dll"))
            {
                FileInfo info = new FileInfo(fileName);
                Assembly.LoadFile(info.FullName);
            }

            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                try
                {
                    if (!string.IsNullOrEmpty(assembly.Location))
                        references.Add(MetadataReference.CreateFromFile(assembly.Location));
                }
                catch (NotSupportedException ex)
                {
                }
            }

            CSharpCompilation compilation = CSharpCompilation.Create(
                assemblyName,
                syntaxTrees: new[] { syntaxTree },
                references: references,
                options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            using (var ms = new MemoryStream())
            {
                EmitResult result = compilation.Emit(ms);

                if (!result.Success)
                {
                    IEnumerable<Diagnostic> failures = result.Diagnostics.Where(diagnostic =>
                        diagnostic.IsWarningAsError ||
                        diagnostic.Severity == DiagnosticSeverity.Error);

                    foreach (Diagnostic diagnostic in failures)
                    {
                        Console.Error.WriteLine("\t{0}: {1}", diagnostic.Id, diagnostic.GetMessage());
                    }
                }
                else
                {
                    ms.Seek(0, SeekOrigin.Begin);

                    byte[] byteArray = ms.ToArray();

                    string formatFileName = string.Format("{0}.dll", assemblyName);
                    string fullPath = Path.Combine(Path.GetTempPath(), formatFileName);
                    File.WriteAllBytes(fullPath, byteArray);

                    Assembly assembly = Assembly.LoadFrom(fullPath);
                    s_dynamicAssembliesByName.Add(assemblyName, assembly);

                    var type = assembly.GetType(fullNameSpace);
                    var instance = assembly.CreateInstance(fullNameSpace);
                    var meth = type.GetMember("Write").First() as MethodInfo;
                    meth.Invoke(instance, new[] { fullNameSpace });
                }
            }
        }
    }
}